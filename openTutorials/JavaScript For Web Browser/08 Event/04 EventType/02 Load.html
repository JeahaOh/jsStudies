<!DOCTYPE html>
<html>
<head>
  <style>
    html { border : 5px solid lightslategrey; padding: 30px; }
  </style>
  <script>
    //  1.
    var t = document.getElementById('target');
    console.log('Call From Head : ', t);

    //  3.
    window.addEventListener('load', function() {
      var t = document.getElementById('target');
      console.log('EventListener load');
      console.log('Call From Head By EventListener : ', t);
    });

    //  4.
    window.addEventListener('DOMContentLoaded', function() {
      console.log('EventListener DOMContentLoaded');
    });
  </script>
</head>
<body>
  <p id='target'>HELL</p>
  <pre>
웹페이지를 프로그래밍적으로 제어하기 위해서는 웹페이지의 모든 요소에 대한 처리가 끝나야 한다.
이것을 알려주는 이벤트가 load, DOMContentLeaded이다.


1의 실행 결과는 null이다. target이 로딩 되기 전에 js가 실행되었기 때문.

이를 해결하기위해서 2와 같이 js를 문서 끝에 위치시킨다.

또 다른 방법은 3과 같이 load 이벤트를 이용하는 것이다.

그런데 load 이벤트는 문서내의 모든 리소스(이미지, 스크립트)의 다운로드가 끝난후에 실행된다.
이것은 어플리케이션의 구동을 너무 지연시키는 부작용을 초래할 수 있다.
DOMContentLoaded는 문서에서 스크립트 작업을 할 수 있을 때 실행되기 때문에 콘텐츠 다운로드를 기다릴 필요가 없다. 4
  </pre>

  <script>
    //  2.
    var t = document.getElementById('target');
    console.log('Call From Body End : ', t);
  </script>
</body>
</html>